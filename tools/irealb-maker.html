<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iRealPro Maker - MIDI Mini Apps</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    
    <style>
        .irealb-maker-section {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        
        .chord-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 30px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .chord-name {
            font-size: 3em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .status-message {
            font-size: 1.2em;
            margin-top: 10px;
            opacity: 0.9;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }
        
        .controls button {
            flex: 1;
            min-width: 150px;
            padding: 15px 25px;
            font-size: 1.1em;
        }
        
        .recording-indicator {
            background: #ff4444;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .chord-sequence {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .chord-sequence h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .chord-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        
        .chord-cell {
            background: white;
            border: 3px solid #667eea;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .chord-cell:hover {
            background: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }
        
        .chord-cell.selected {
            background: #667eea;
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
        }
        
        .chord-cell.empty-measure {
            background: #f5f5f5;
            border-style: dashed;
            border-color: #ccc;
            color: #999;
        }
        
        .chord-cell .measure-label {
            font-size: 0.75em;
            opacity: 0.7;
            margin-bottom: 4px;
        }
        
        .chord-cell .chord-name {
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .chord-cell .beat-info {
            font-size: 0.7em;
            margin-top: 4px;
            opacity: 0.8;
        }
        
        .chord-cell .marker-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #ffc107;
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .chord-item {
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chord-item .measure-num {
            opacity: 0.7;
            font-size: 0.8em;
            margin-right: 5px;
        }
        
        .chord-item .chord-text {
            flex: 1;
        }
        
        .chord-item-actions {
            display: flex;
            gap: 4px;
        }
        
        .chord-item-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background 0.2s;
        }
        
        .chord-item-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .inversion-selector {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .inversion-selector h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .inversion-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .inversion-btn {
            padding: 8px 16px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: #667eea;
            transition: all 0.2s;
        }
        
        .inversion-btn:hover, .inversion-btn.selected {
            background: #667eea;
            color: white;
        }
        
        .midi-status {
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .midi-status.connected {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .back-navigation {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .placeholder-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.2em;
        }
        
        .device-group {
            margin-bottom: 20px;
        }
        
        .device-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .device-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
        }
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        .time-signature-help {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        
        /* Modal Dialog Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-dialog {
            background: white;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px 12px 0 0;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.5em;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-footer {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        /* Setup Wizard Styles */
        .setup-wizard {
            display: none;
        }
        
        .setup-wizard.active {
            display: block;
        }
        
        /* Hide form sections by default in editing mode */
        .editing-mode .setup-sections {
            display: none;
        }
        
        .editing-mode .workspace {
            display: block !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-text">
                    <h1 data-i18n="irealbMaker.title">üéµ iRealPro Maker</h1>
                    <p data-i18n="irealbMaker.subtitle">Create iRealPro chord charts from MIDI input</p>
                </div>
            </div>
        </header>

        <main>
            <div class="back-navigation">
                <button id="backBtn" class="btn btn-secondary" data-i18n="tools.backToTools">‚Üê Back to Tools</button>
            </div>

            <div class="midi-status" id="midiStatus">
                <strong data-i18n="irealbMaker.midiStatus">MIDI Status:</strong> <span id="statusText" data-i18n="irealbMaker.initializing">Initializing...</span>
            </div>

            <div class="irealb-maker-section">
                <!-- Hidden fields to store form values - populated from wizard -->
                <input type="hidden" id="songName" value="">
                <input type="hidden" id="authorName" value="">
                <input type="hidden" id="timeSignature" value="44">
                <input type="hidden" id="musicStyle" value="Medium Swing">
                <input type="hidden" id="keySignature" value="C">
                <input type="hidden" id="bpm" value="120">
                <input type="hidden" id="totalMeasures" value="32">
                <input type="hidden" id="startMeasure" value="1">
                <input type="hidden" id="endMeasure" value="">
                <input type="hidden" id="sectionType" value="A">
                <input type="hidden" id="sectionMeasure" value="1">
                <select id="midiInput" style="display: none;" aria-label="Select MIDI input device">
                    <option value="">No device selected</option>
                </select>

                <div class="chord-display" role="region" aria-atomic="true">
                    <div class="chord-name" id="chordName">
                        <span class="placeholder-text" data-i18n="irealbMaker.readyToRecord">Ready to record...</span>
                    </div>
                    <div class="status-message" id="statusMessage"></div>
                </div>

                <!-- Hidden div for screen reader announcements -->
                <div class="sr-only" role="status" aria-live="assertive" aria-atomic="true" id="announcements"></div>

                <!-- Controls -->
                <div class="controls">
                    <button id="startBtn" class="btn btn-primary" data-i18n="irealbMaker.startRecording">
                        ‚ñ∂Ô∏è Start Recording
                    </button>
                    <button id="stopBtn" class="btn btn-danger" disabled data-i18n="irealbMaker.stopRecording">
                        ‚èπÔ∏è Stop Recording
                    </button>
                    <button id="downloadBtn" class="btn btn-success" disabled data-i18n="irealbMaker.download">
                        üíæ Download iRealPro File
                    </button>
                    <button id="downloadJsonBtn" class="btn btn-success" disabled data-i18n="irealbMaker.downloadJson">
                        üì• Download Progress (JSON)
                    </button>
                    <button id="uploadJsonBtn" class="btn btn-secondary" data-i18n="irealbMaker.uploadJson">
                        üì§ Upload Progress (JSON)
                    </button>
                    <button id="resetBtn" class="btn btn-secondary" data-i18n="irealbMaker.reset">
                        üîÑ Reset
                    </button>
                </div>
                
                <!-- Hidden file input for JSON upload -->
                <input type="file" id="jsonFileInput" accept=".json" style="display: none;" aria-label="Load saved progress from JSON file">

                <!-- Keyboard Shortcuts Help -->
                <div class="keyboard-shortcuts" id="keyboardShortcuts" style="background: #f0f4ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="color: #667eea; margin-bottom: 10px;">‚å®Ô∏è Keyboard Shortcuts <span style="font-size: 0.8em; opacity: 0.8;">(Press H for help)</span></h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; font-size: 0.9em;">
                        <div><strong>H</strong>: Show/hide help</div>
                        <div><strong>N</strong>: Focus workspace</div>
                        <div><strong>T</strong>: Tempo settings</div>
                        <div><strong>M</strong>: MIDI devices</div>
                        <div><strong>Spacebar</strong>: Play/pause</div>
                        <div><strong>Ctrl+,</strong>: Song settings</div>
                        <div><strong>R</strong>: Start/Stop Recording</div>
                        <div><strong>E</strong>: Edit chord (MIDI)</div>
                        <div><strong>Shift+E</strong>: Edit chord (keyboard)</div>
                        <div><strong>S</strong>: Add section</div>
                        <div><strong>V</strong>: Add volta (first/second ending)</div>
                        <div><strong>Backspace</strong>: Delete current chord</div>
                        <div><strong>Delete</strong>: Delete marker range</div>
                        <div><strong>Shift+Backspace</strong>: Delete section</div>
                        <div><strong>Ctrl+X</strong>: Cut (marker range)</div>
                        <div><strong>Ctrl+C</strong>: Copy (marker range)</div>
                        <div><strong>Ctrl+V</strong>: Paste at cursor</div>
                        <div><strong>Shift+S</strong>: Save to storage</div>
                        <div><strong>Shift+O</strong>: Open from storage</div>
                        <div><strong>Shift+D</strong>: Download iReal</div>
                        <div><strong>Shift+J</strong>: Download/Load JSON</div>
                        <div><strong>Shift+W</strong>: Close with save</div>
                        <div><strong>‚Üê/‚Üí</strong>: Navigate chords</div>
                        <div><strong>Ctrl+‚Üê/‚Üí</strong>: Jump measures</div>
                        <div><strong>[</strong>: Set start marker</div>
                        <div><strong>]</strong>: Set end marker</div>
                        <div><strong>Esc</strong>: Cancel</div>
                    </div>
                </div>

                <!-- Recorded Chord Sequence -->
                <!-- Using role="application" because this is a custom music notation workspace
                     with specialized keyboard navigation that doesn't match standard HTML patterns.
                     Standard screen reader shortcuts are overridden to provide music-specific navigation. -->
                <div class="chord-sequence workspace" id="chordSequenceSection" style="display: none;" tabindex="0" role="application" aria-label="Chord editing workspace. Press H for help, use arrow keys to navigate chords, press N to return here from other controls.">
                    <h3 data-i18n="irealbMaker.recordedChords">Recorded Chord Sequence</h3>
                    <div class="chord-list" id="chordList" aria-hidden="true" aria-label="Visual chord grid"></div>
                </div>
            </div>
            
            <!-- Setup Wizard Modal -->
            <div id="setupWizardModal" class="modal-overlay">
                <div class="modal-dialog">
                    <div class="modal-header">
                        <h2>Song Setup</h2>
                    </div>
                    <div class="modal-body">
                        <div id="wizardContent">
                            <!-- Song Information -->
                            <div class="form-group">
                                <label for="wizard-songName">Song Name:</label>
                                <input type="text" id="wizard-songName" placeholder="Enter song name" required>
                            </div>
                            <div class="form-group">
                                <label for="wizard-authorName">Author/Composer:</label>
                                <input type="text" id="wizard-authorName" placeholder="Enter author name">
                            </div>
                            <div class="form-group">
                                <label for="wizard-timeSignature">Time Signature:</label>
                                <select id="wizard-timeSignature">
                                    <option value="44">4/4 (Common Time)</option>
                                    <option value="34">3/4 (Waltz)</option>
                                    <option value="54">5/4</option>
                                    <option value="68">6/8</option>
                                    <option value="78">7/8</option>
                                    <option value="24">2/4</option>
                                </select>
                                <div class="time-signature-help">Count-in will be announced for the first 2 measures</div>
                            </div>
                            <div class="form-group">
                                <label for="wizard-musicStyle">Music Style:</label>
                                <select id="wizard-musicStyle">
                                    <option value="Medium Swing">Medium Swing</option>
                                    <option value="Up Tempo Swing">Up Tempo Swing</option>
                                    <option value="Ballad">Ballad</option>
                                    <option value="Even 8ths">Even 8ths</option>
                                    <option value="Bossa Nova">Bossa Nova</option>
                                    <option value="Latin">Latin</option>
                                    <option value="Jazz Waltz">Jazz Waltz</option>
                                    <option value="Medium Up Swing">Medium Up Swing</option>
                                    <option value="Fast Swing">Fast Swing</option>
                                    <option value="Slow Swing">Slow Swing</option>
                                    <option value="Funk">Funk</option>
                                    <option value="Samba">Samba</option>
                                    <option value="Afro Cuban">Afro Cuban</option>
                                    <option value="Blues">Blues</option>
                                    <option value="Rock">Rock</option>
                                    <option value="Pop">Pop</option>
                                    <option value="Folk">Folk</option>
                                    <option value="Country">Country</option>
                                    <option value="R&B">R&amp;B</option>
                                    <option value="Gospel">Gospel</option>
                                </select>
                                <div class="time-signature-help">Select the music style for your song</div>
                            </div>
                            <div class="form-group">
                                <label for="wizard-keySignature">Key Signature:</label>
                                <select id="wizard-keySignature">
                                    <option value="C">C Major</option>
                                    <option value="Db">Db Major</option>
                                    <option value="D">D Major</option>
                                    <option value="Eb">Eb Major</option>
                                    <option value="E">E Major</option>
                                    <option value="F">F Major</option>
                                    <option value="Gb">Gb Major</option>
                                    <option value="G">G Major</option>
                                    <option value="Ab">Ab Major</option>
                                    <option value="A">A Major</option>
                                    <option value="Bb">Bb Major</option>
                                    <option value="B">B Major</option>
                                    <option value="A-">A Minor</option>
                                    <option value="Bb-">Bb Minor</option>
                                    <option value="B-">B Minor</option>
                                    <option value="C-">C Minor</option>
                                    <option value="C#-">C# Minor</option>
                                    <option value="D-">D Minor</option>
                                    <option value="Eb-">Eb Minor</option>
                                    <option value="E-">E Minor</option>
                                    <option value="F-">F Minor</option>
                                    <option value="F#-">F# Minor</option>
                                    <option value="G-">G Minor</option>
                                    <option value="G#-">G# Minor</option>
                                </select>
                                <div class="time-signature-help">Select the key signature for your song</div>
                            </div>
                            
                            <!-- Tempo Settings -->
                            <div class="form-group">
                                <label for="wizard-bpm">BPM (Tempo):</label>
                                <input type="number" id="wizard-bpm" value="120" min="40" max="240" step="1">
                                <div class="time-signature-help">Metronome tempo (40-240 beats per minute)</div>
                                <div class="time-signature-help" style="font-weight: bold; color: #667eea;">
                                    ‚ö†Ô∏è Note: BPM is for metronome during recording only, not saved to iReal Pro file
                                </div>
                            </div>
                            
                            <!-- Song Length -->
                            <div class="form-group">
                                <label for="wizard-totalMeasures">Total Measures in Song:</label>
                                <input type="number" id="wizard-totalMeasures" value="32" min="1" max="999" step="1">
                                <div class="time-signature-help">Set the total length of your song</div>
                            </div>
                            
                            <div class="time-signature-help" style="margin-top: 20px; padding: 10px; background: #f0f4ff; border-radius: 6px;">
                                <strong>Note:</strong> Use [ and ] keys during editing to set start/end recording markers on specific measures.
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button id="wizardCancelBtn" class="btn btn-secondary">Cancel</button>
                        <button id="wizardDoneBtn" class="btn btn-primary">Start Editing</button>
                    </div>
                </div>
            </div>
            
            <!-- Tempo/BPM Settings Modal -->
            <div id="tempoModal" class="modal-overlay">
                <div class="modal-dialog" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2>Tempo Settings</h2>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="modalBpm">BPM (Tempo):</label>
                            <input type="number" id="modalBpm" min="40" max="240" value="120" aria-label="Beats per minute">
                            <div class="time-signature-help">Metronome tempo (40-240 beats per minute)</div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button id="tempoCloseBtn" class="btn btn-primary">Done</button>
                    </div>
                </div>
            </div>
            
            <!-- MIDI Device Selection Modal -->
            <div id="midiDeviceModal" class="modal-overlay">
                <div class="modal-dialog" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2>MIDI Devices</h2>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="modalMidiInput">MIDI Input Device:</label>
                            <select id="modalMidiInput" aria-label="Select MIDI input device">
                                <option value="">No device selected</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button id="midiDeviceCloseBtn" class="btn btn-primary">Done</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        import { t, getCurrentLanguage } from '../src/i18n.js';
        import { midiNoteToName, getPitchClass, noteNameToSemitone, detectChord } from '../src/chord-utils.js';
        
        let midiAccess = null;
        let selectedInput = null;
        let activeNotes = new Set();
        let currentChord = null;
        let recordedChords = [];
        let definedSections = []; // Array to store section definitions
        let isRecording = false;
        let isCountingIn = false;
        let currentBeat = 0;
        let currentMeasure = 0;
        
        let audioContext = null;
        let metronomeInterval = null;
        let lastRecordedChord = null; // Track last chord to avoid duplicates
        let chordNotesPressed = new Set(); // Notes that were pressed for current chord
        let chordBeatPosition = null; // Beat when first note of chord was pressed
        let chordMeasurePosition = null; // Measure when first note of chord was pressed
        
        // Volta (repeat endings) tracking - stores endings like {measure: 8, type: 1} or {measure: 16, type: 2}
        let voltaEndings = [];
        
        // Clipboard for cut/copy/paste operations
        let clipboardChords = [];
        
        // Chord detection algorithm is now imported from chord-utils.js
        
        // Initialize Web Audio API for metronome
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        // Play metronome click
        function playClick(isAccent = false) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = isAccent ? 1000 : 800;
            gainNode.gain.value = isAccent ? 0.3 : 0.2;
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
            
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
        }
        
        // Announce count for screen reader
        function announceCount(text) {
            const announcements = document.getElementById('announcements');
            announcements.textContent = text;
        }
        
        // Get time signature info
        function getTimeSignatureInfo() {
            const ts = document.getElementById('timeSignature').value;
            const numerator = parseInt(ts[0]);
            const denominator = parseInt(ts[1]);
            return { numerator, denominator };
        }
        
        // Start metronome with count-in
        function startMetronome() {
            const { numerator } = getTimeSignatureInfo();
            const bpm = parseInt(document.getElementById('bpm').value) || 120;
            const startMeasureNum = parseInt(document.getElementById('startMeasure').value) || 1;
            const beatDuration = 60000 / bpm;
            
            currentBeat = 0;
            currentMeasure = 0; // Count-in always starts at 0
            isCountingIn = true;
            
            // Store the actual start measure for later
            window.actualStartMeasure = startMeasureNum;
            
            metronomeInterval = setInterval(() => {
                currentBeat++;
                const isAccent = currentBeat === 1;
                playClick(isAccent);
                
                // Announce counts during count-in
                if (isCountingIn) {
                    if (currentMeasure === 0) {
                        // First measure: announce on beats 1 and 3 for 4/4 (jazz convention)
                        if (numerator === 4) {
                            if (currentBeat === 1) {
                                announceCount('one');
                            } else if (currentBeat === 3) {
                                announceCount('two');
                            }
                        } else {
                            // For other time signatures, announce beat numbers
                            announceCount(currentBeat.toString());
                        }
                    } else if (currentMeasure === 1) {
                        // Second measure: announce all beats
                        if (numerator === 4) {
                            // For 4/4, use beat names only (no numbers)
                            const beatNames = ['', 'one', 'two', 'three', 'four'];
                            announceCount(beatNames[currentBeat]);
                        } else {
                            // For other time signatures, use numbers
                            announceCount(currentBeat.toString());
                        }
                    }
                }
                
                if (currentBeat >= numerator) {
                    currentBeat = 0;
                    currentMeasure++;
                    
                    // After 2 measures of count-in, start recording
                    if (isCountingIn && currentMeasure >= 2) {
                        isCountingIn = false;
                        isRecording = true;
                        updateStatusMessage('Recording...', true);
                        // Don't announce "Recording started" - user knows from last count-in beat
                        lastRecordedChord = null; // Reset on recording start
                    }
                    
                    // Check if we've reached the end measure
                    if (isRecording && !isCountingIn) {
                        const endMeasure = parseInt(document.getElementById('endMeasure').value);
                        const actualMeasure = window.actualStartMeasure + (currentMeasure - 2);
                        
                        // Check for new section and announce it
                        const sectionInfo = getSectionForMeasure(actualMeasure);
                        if (sectionInfo) {
                            // Create a unique identifier for this section (type + measure)
                            const sectionId = `${sectionInfo.type}_${sectionInfo.measure}`;
                            if (sectionId !== window.lastAnnouncedSectionId) {
                                // Announce section change quickly
                                if (sectionInfo.type.length === 1) {
                                    announceCount(`Section ${sectionInfo.type}`);
                                } else {
                                    announceCount(sectionInfo.type);
                                }
                                window.lastAnnouncedSectionId = sectionId;
                            }
                        }
                        
                        if (endMeasure && actualMeasure > endMeasure) {
                            // Stop recording automatically
                            stopMetronome();
                            isRecording = false;
                            isCountingIn = false;
                            updateStatusMessage('Recording stopped (end measure reached)', false);
                            announceCount('Recording stopped');
                            
                            document.getElementById('startBtn').disabled = false;
                            document.getElementById('stopBtn').disabled = true;
                            document.getElementById('downloadBtn').disabled = recordedChords.length === 0;
                        }
                    }
                }
            }, beatDuration);
        }
        
        // Stop metronome
        function stopMetronome() {
            if (metronomeInterval) {
                clearInterval(metronomeInterval);
                metronomeInterval = null;
            }
        }
        
        // Update status message
        function updateStatusMessage(message, isRecording = false) {
            const statusMsg = document.getElementById('statusMessage');
            statusMsg.textContent = message;
            if (isRecording) {
                statusMsg.className = 'status-message recording-indicator';
            } else {
                statusMsg.className = 'status-message';
            }
        }
        
        // Current selected chord index for keyboard navigation
        let selectedChordIndex = -1;
        
        // Update chord list display
        function updateChordList() {
            const chordList = document.getElementById('chordList');
            const section = document.getElementById('chordSequenceSection');
            
            if (recordedChords.length > 0) {
                section.style.display = 'block';
                
                // Group chords by measure
                const chordsByMeasure = {};
                const totalMeasures = parseInt(document.getElementById('totalMeasures').value) || 32;
                
                recordedChords.forEach(item => {
                    if (!chordsByMeasure[item.measure]) {
                        chordsByMeasure[item.measure] = [];
                    }
                    chordsByMeasure[item.measure].push(item);
                });
                
                // Generate cells for all measures
                let html = '';
                for (let m = 1; m <= totalMeasures; m++) {
                    const chordsInMeasure = chordsByMeasure[m] || [];
                    
                    if (chordsInMeasure.length > 0) {
                        // Measure has chords
                        const item = chordsInMeasure[0]; // Use first chord for display
                        const chordText = item.chord.type ? `${item.chord.root}${item.chord.type}` : item.chord.root;
                        const inversionText = item.inversion ? `/${item.inversion}` : '';
                        const beatInfo = item.beat ? `:${item.beat}` : '';
                        
                        // Find the actual index in recordedChords array
                        const actualIndex = recordedChords.findIndex(c => c === item);
                        
                        // Check if this is a marker
                        const startMarker = parseInt(document.getElementById('startMeasure').value) === m;
                        const endMarker = parseInt(document.getElementById('endMeasure').value) === m;
                        const voltaEnding = voltaEndings.find(v => v.measure === m);
                        
                        let markerBadge = '';
                        if (voltaEnding) {
                            markerBadge = `<span class="marker-badge" style="background: #28a745;">VOLTA ${voltaEnding.type}</span>`;
                        } else if (startMarker) {
                            markerBadge = '<span class="marker-badge">START</span>';
                        } else if (endMarker) {
                            markerBadge = '<span class="marker-badge">END</span>';
                        }
                        
                        html += `<div class="chord-cell" data-index="${actualIndex}" data-measure="${m}" 
                                     tabindex="-1" role="button" aria-hidden="true"
                                     data-beat="${item.beat || ''}">
                            ${markerBadge}
                            <div class="measure-label">M${m}</div>
                            <div class="chord-name">${chordText}${inversionText}</div>
                            ${beatInfo ? `<div class="beat-info">${beatInfo}</div>` : ''}
                        </div>`;
                    } else {
                        // Empty measure
                        html += `<div class="chord-cell empty-measure" data-measure="${m}" 
                                     tabindex="-1" role="button" aria-hidden="true">
                            <div class="measure-label">M${m}</div>
                            <div class="chord-name" style="opacity: 0.5;">‚Äî</div>
                        </div>`;
                    }
                }
                
                chordList.innerHTML = html;
                
                // Add click and keyboard event listeners to cells
                document.querySelectorAll('.chord-cell').forEach((cell, index) => {
                    cell.addEventListener('click', () => selectChord(index));
                    cell.addEventListener('keydown', handleChordCellKeydown);
                });
                
            } else {
                section.style.display = 'none';
            }
            
            // Update download button states
            updateDownloadButtonStates();
        }
        
        // Select a chord cell
        function selectChord(index) {
            // Remove previous selection
            document.querySelectorAll('.chord-cell.selected').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Select new cell
            const cells = document.querySelectorAll('.chord-cell');
            if (index >= 0 && index < cells.length) {
                selectedChordIndex = index;
                cells[index].classList.add('selected');
                cells[index].focus();
                
                // Announce to screen reader with internationalization
                const measure = cells[index].getAttribute('data-measure');
                const chordName = cells[index].querySelector('.chord-name')?.textContent || '';
                const beatAttr = cells[index].getAttribute('data-beat');
                const isEmptyMeasure = cells[index].classList.contains('empty-measure');
                const voltaEnding = voltaEndings.find(v => v.measure === parseInt(measure));
                
                let announcement = '';
                if (isEmptyMeasure || chordName === '‚Äî') {
                    // Empty measure announcement
                    announcement = `${t('irealbMaker.emptyMeasure')} ${measure}`;
                } else {
                    // Chord announcement with optional beat information
                    // Format: "Bb major measure 4" or "Bb major measure 4, beat 2"
                    const chordText = chordName.trim();
                    announcement = `${chordText} ${t('irealbMaker.measure').toLowerCase()} ${measure}`;
                    
                    // Add beat information if the chord is not the only one in the measure
                    if (beatAttr && beatAttr !== '') {
                        announcement += `, ${t('irealbMaker.beat')} ${beatAttr}`;
                    }
                }
                
                // Add volta ending information
                if (voltaEnding) {
                    announcement += `, volta ending ${voltaEnding.type}`;
                }
                
                announceChange(announcement);
            }
        }
        
        // Handle keyboard navigation in chord cells
        function handleChordCellKeydown(e, cellElement = null) {
            const cells = Array.from(document.querySelectorAll('.chord-cell'));
            let currentIndex;
            
            // Determine current index based on cellElement parameter or event target
            if (cellElement) {
                currentIndex = cells.indexOf(cellElement);
            } else if (e.target && e.target.classList && e.target.classList.contains('chord-cell')) {
                currentIndex = cells.indexOf(e.target);
            } else {
                currentIndex = selectedChordIndex;
            }
            
            if (currentIndex === -1) return;
            
            let handled = true;
            
            switch(e.key) {
                case 'ArrowRight':
                    if (e.ctrlKey) {
                        // Ctrl+Right: Next measure with chord
                        const nextChordIndex = cells.findIndex((cell, idx) => 
                            idx > currentIndex && !cell.classList.contains('empty-measure')
                        );
                        if (nextChordIndex !== -1) {
                            selectChord(nextChordIndex);
                        }
                    } else {
                        // Right: Next chord
                        if (currentIndex < cells.length - 1) {
                            selectChord(currentIndex + 1);
                        }
                    }
                    break;
                    
                case 'ArrowLeft':
                    if (e.ctrlKey) {
                        // Ctrl+Left: Previous measure with chord
                        const prevChordIndex = cells.slice(0, currentIndex).reverse().findIndex(
                            cell => !cell.classList.contains('empty-measure')
                        );
                        if (prevChordIndex !== -1) {
                            selectChord(currentIndex - prevChordIndex - 1);
                        }
                    } else {
                        // Left: Previous chord
                        if (currentIndex > 0) {
                            selectChord(currentIndex - 1);
                        }
                    }
                    break;
                    
                case '[':
                    // Set start marker
                    e.preventDefault();
                    const startMeasure = cells[currentIndex].getAttribute('data-measure');
                    document.getElementById('startMeasure').value = startMeasure;
                    announceChange(`Start marker set at measure ${startMeasure}`);
                    updateChordList(); // Refresh to show marker
                    selectChord(currentIndex); // Reselect after refresh
                    break;
                    
                case ']':
                    // Set end marker
                    e.preventDefault();
                    const endMeasure = cells[currentIndex].getAttribute('data-measure');
                    document.getElementById('endMeasure').value = endMeasure;
                    announceChange(`End marker set at measure ${endMeasure}`);
                    updateChordList(); // Refresh to show marker
                    selectChord(currentIndex); // Reselect after refresh
                    break;
                    
                case 'e':
                case 'E':
                    // Edit chord (E = MIDI, Shift+E = keyboard)
                    e.preventDefault();
                    const dataIndex = cells[currentIndex].getAttribute('data-index');
                    if (dataIndex !== null) {
                        editChord(parseInt(dataIndex), e.shiftKey);
                    }
                    break;
                    
                case 'Backspace':
                    // Backspace: Delete current chord only
                    if (!e.shiftKey) {
                        e.preventDefault();
                        const deleteIndex = cells[currentIndex].getAttribute('data-index');
                        if (deleteIndex !== null) {
                            deleteChord(parseInt(deleteIndex));
                        }
                    }
                    // Shift+Backspace handled in global handler
                    break;
                    
                default:
                    handled = false;
            }
            
            if (handled) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
        
        // Update download button states based on whether we have chords
        function updateDownloadButtonStates() {
            const hasChords = recordedChords.length > 0;
            document.getElementById('downloadBtn').disabled = !hasChords;
            document.getElementById('downloadJsonBtn').disabled = !hasChords;
        }
        
        // Set recording marker function
        function setRecordMarker(index, type) {
            const item = recordedChords[index];
            if (type === 'start') {
                document.getElementById('startMeasure').value = item.measure;
                announceChange(`Start recording marker set to measure ${item.measure}`);
            } else if (type === 'end') {
                document.getElementById('endMeasure').value = item.measure;
                announceChange(`End recording marker set to measure ${item.measure}`);
            }
        }
        
        // Edit chord function - supports MIDI (default) and keyboard editing
        let editingChordIndex = -1;
        let editingChordNotes = new Set();
        
        function editChord(index, useKeyboard = false) {
            const item = recordedChords[index];
            
            if (useKeyboard) {
                // Keyboard editing (Shift+E)
                const newRoot = prompt(`Edit chord root (current: ${item.chord.root}):`, item.chord.root);
                if (newRoot && newRoot.trim()) {
                    item.chord.root = newRoot.trim();
                    updateChordList();
                    announceChange(`Chord at measure ${item.measure} updated to ${newRoot}`);
                }
            } else {
                // MIDI editing mode (E key - default)
                editingChordIndex = index;
                editingChordNotes.clear();
                announceChange(`Edit mode: Play a chord on your MIDI keyboard to replace the chord at measure ${item.measure}. Press Escape to cancel.`);
                
                // Show visual feedback
                const cells = document.querySelectorAll('.chord-cell');
                const cellIndex = Array.from(cells).findIndex(cell => 
                    parseInt(cell.getAttribute('data-index')) === index
                );
                if (cellIndex !== -1) {
                    cells[cellIndex].style.background = '#ffc107';
                    cells[cellIndex].style.animation = 'pulse 1s infinite';
                }
            }
        }
        
        // Handle MIDI editing
        let allEditNotes = new Set(); // Track all notes pressed during edit
        
        function handleMIDIEdit(midiNote, isNoteOn) {
            if (editingChordIndex === -1) return false;
            
            if (isNoteOn) {
                editingChordNotes.add(midiNote);
                allEditNotes.add(midiNote); // Remember this note was part of the chord
            } else {
                editingChordNotes.delete(midiNote);
                
                // When all notes released, analyze and update chord
                if (editingChordNotes.size === 0 && allEditNotes.size > 0) {
                    const noteNames = Array.from(allEditNotes)
                        .sort((a, b) => a - b)
                        .map(midiNoteToName);
                    
                    const chordInfo = detectChord(noteNames);
                    if (chordInfo) {
                        recordedChords[editingChordIndex].chord = chordInfo;
                        updateChordList();
                        announceChange(`Chord updated to ${chordInfo.root}${chordInfo.type || ''}`);
                    }
                    
                    // Exit edit mode
                    editingChordIndex = -1;
                    allEditNotes.clear();
                    
                    // Remove visual feedback
                    const cells = document.querySelectorAll('.chord-cell');
                    cells.forEach(cell => {
                        cell.style.background = '';
                        cell.style.animation = '';
                    });
                }
            }
            
            return true;
        }
        
        // Add inversion function
        function addInversion(index) {
            const item = recordedChords[index];
            const chordRoot = item.chord.root;
            
            // Create inversion selector dialog
            const inversionDialog = document.createElement('div');
            inversionDialog.className = 'inversion-selector';
            inversionDialog.setAttribute('role', 'dialog');
            inversionDialog.setAttribute('aria-label', 'Select chord inversion');
            
            const notes = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
            
            inversionDialog.innerHTML = `
                <h4>Select Bass Note for Inversion</h4>
                <div class="inversion-options" role="group" aria-label="Available bass notes">
                    ${notes.map(note => `
                        <button class="inversion-btn" onclick="setInversion(${index}, '${note}')" 
                                aria-label="Set bass note to ${note}">
                            ${note}
                        </button>
                    `).join('')}
                    <button class="inversion-btn" onclick="setInversion(${index}, '')" 
                            aria-label="Remove inversion">
                        Remove
                    </button>
                    <button class="inversion-btn" onclick="closeInversionDialog()" 
                            style="background: #ff4444; color: white; border-color: #ff4444;"
                            aria-label="Cancel inversion selection">
                        Cancel
                    </button>
                </div>
            `;
            
            // Insert after the chord item
            const chordItem = document.querySelector(`.chord-item[data-index="${index}"]`);
            if (chordItem) {
                const existingDialog = chordItem.nextElementSibling;
                if (existingDialog && existingDialog.classList.contains('inversion-selector')) {
                    existingDialog.remove();
                } else {
                    chordItem.after(inversionDialog);
                    inversionDialog.querySelector('.inversion-btn').focus();
                }
            }
        }
        
        // Set inversion
        function setInversion(index, bassNote) {
            recordedChords[index].inversion = bassNote;
            updateChordList();
            closeInversionDialog();
            const item = recordedChords[index];
            const chordText = item.chord.type ? `${item.chord.root}${item.chord.type}` : item.chord.root;
            const inversionText = bassNote ? ` with bass note ${bassNote}` : ' (inversion removed)';
            announceChange(`Chord ${chordText} at measure ${item.measure} updated${inversionText}`);
        }
        
        // Close inversion dialog
        function closeInversionDialog() {
            const dialogs = document.querySelectorAll('.inversion-selector');
            dialogs.forEach(dialog => dialog.remove());
        }
        
        // Delete chord function
        function deleteChord(index) {
            const item = recordedChords[index];
            if (confirm(`Delete chord at measure ${item.measure}?`)) {
                recordedChords.splice(index, 1);
                updateChordList();
                announceChange(`Chord at measure ${item.measure} deleted`);
            }
        }
        
        // Announce changes for screen reader
        function announceChange(message) {
            const announcements = document.getElementById('announcements');
            announcements.textContent = message;
        }
        
        // Add section definition
        function addSection() {
            const sectionType = document.getElementById('sectionType').value;
            const measure = parseInt(document.getElementById('sectionMeasure').value) || 1;
            
            // Check if section already exists at this measure
            const existingIndex = definedSections.findIndex(s => s.measure === measure);
            if (existingIndex !== -1) {
                if (!confirm(`A section already exists at measure ${measure}. Replace it?`)) {
                    return;
                }
                definedSections[existingIndex] = { type: sectionType, measure: measure };
            } else {
                definedSections.push({ type: sectionType, measure: measure });
            }
            
            // Sort sections by measure
            definedSections.sort((a, b) => a.measure - b.measure);
            
            updateSectionList();
            
            // Announce the addition
            if (sectionType.length === 1) {
                announceChange(`Section ${sectionType} added at measure ${measure}`);
            } else {
                announceChange(`${sectionType} section added at measure ${measure}`);
            }
            
            // Increment measure number for next section
            document.getElementById('sectionMeasure').value = measure + 4;
        }
        
        // Update section list display
        function updateSectionList() {
            const sectionList = document.getElementById('sectionList');
            const section = document.getElementById('sectionListSection');
            
            if (definedSections.length > 0) {
                section.style.display = 'block';
                sectionList.innerHTML = definedSections.map((item, index) => {
                    return `<div class="chord-item" role="group" aria-label="${item.type} at measure ${item.measure}">
                        <span class="measure-num">M${item.measure}:</span>
                        <span class="chord-text">${item.type}</span>
                        <div class="chord-item-actions">
                            <button class="chord-item-btn" onclick="deleteSection(${index})" aria-label="Delete ${item.type} section at measure ${item.measure}">
                                ‚ùå
                            </button>
                        </div>
                    </div>`;
                }).join('');
            } else {
                section.style.display = 'none';
            }
        }
        
        // Delete section definition
        function deleteSection(index) {
            const item = definedSections[index];
            if (confirm(`Delete ${item.type} section at measure ${item.measure}?`)) {
                definedSections.splice(index, 1);
                updateSectionList();
                announceChange(`Section deleted`);
            }
        }
        
        // Get section index and info for a specific measure
        function getSectionForMeasure(measure) {
            // Find the section that starts at or before this measure
            let currentSectionIndex = -1;
            for (let i = 0; i < definedSections.length; i++) {
                if (definedSections[i].measure <= measure) {
                    currentSectionIndex = i;
                } else {
                    break;
                }
            }
            
            if (currentSectionIndex === -1) return null;
            
            return {
                index: currentSectionIndex,
                type: definedSections[currentSectionIndex].type,
                measure: definedSections[currentSectionIndex].measure
            };
        }
        
        // Get the measure range for a section by index
        function getSectionRangeByIndex(sectionIndex) {
            if (sectionIndex < 0 || sectionIndex >= definedSections.length) return null;
            
            const startMeasure = definedSections[sectionIndex].measure;
            const endMeasure = sectionIndex < definedSections.length - 1 
                ? definedSections[sectionIndex + 1].measure - 1
                : parseInt(document.getElementById('totalMeasures').value) || 32;
            
            return { start: startMeasure, end: endMeasure };
        }
        
        // Get the measure range for a section type (finds first occurrence)
        function getSectionRange(sectionType) {
            const sectionIndex = definedSections.findIndex(s => s.type === sectionType);
            if (sectionIndex === -1) return null;
            return getSectionRangeByIndex(sectionIndex);
        }
        
        // Copy chords from previous section (button click when not recording)
        function copyFromPreviousSection(sectionType) {
            const sectionIndex = definedSections.findIndex(s => s.type === sectionType);
            if (sectionIndex <= 0) {
                announceChange("No previous section to copy from");
                return;
            }
            
            const prevSection = definedSections[sectionIndex - 1];
            const prevSectionRange = getSectionRange(prevSection.type);
            const currentSectionRange = getSectionRange(sectionType);
            
            if (!prevSectionRange || !currentSectionRange) {
                announceChange("Unable to determine section ranges");
                return;
            }
            
            // Get chords from previous section
            const previousSectionChords = recordedChords.filter(chord => 
                chord.measure >= prevSectionRange.start && chord.measure <= prevSectionRange.end
            );
            
            if (previousSectionChords.length === 0) {
                announceChange("Previous section is empty");
                return;
            }
            
            // Remove existing chords in current section first
            recordedChords = recordedChords.filter(chord => 
                !(chord.measure >= currentSectionRange.start && chord.measure <= currentSectionRange.end)
            );
            
            // Copy chords with adjusted measure numbers
            const measureOffset = currentSectionRange.start - prevSectionRange.start;
            const copiedChords = previousSectionChords.map(chord => ({
                ...chord,
                measure: chord.measure + measureOffset,
                section: sectionType
            }));
            
            // Add copied chords
            recordedChords.push(...copiedChords);
            recordedChords.sort((a, b) => {
                if (a.measure !== b.measure) return a.measure - b.measure;
                return a.beat - b.beat;
            });
            
            updateChordList();
            announceChange(`Section ${sectionType} copied from ${prevSection.type}`);
        }
        
        // Mark section function (deprecated - kept for backward compatibility with existing chords)
        function markSection(index) {
            const item = recordedChords[index];
            const currentSection = item.section || '';
            const newSection = prompt(`Enter section marker (A, B, C, etc.) for measure ${item.measure}:`, currentSection);
            if (newSection !== null) {
                item.section = newSection.trim().toUpperCase();
                updateChordList();
                if (item.section) {
                    // For single letter sections, say "Section X"
                    if (item.section.length === 1) {
                        announceChange(`Section ${item.section}`);
                    } else {
                        // For longer names (like "Intro", "Verse"), just say the name
                        announceChange(item.section);
                    }
                } else {
                    announceChange(`Section marker removed`);
                }
            }
        }
        
        // Convert chord to iRealb format
        function chordToIRealb(chordItem) {
            if (!chordItem || !chordItem.chord) return ' ';
            
            const chord = chordItem.chord;
            let result = chord.root;
            
            // Convert chord type to iRealb notation
            const typeMap = {
                '': '', // Major
                'm': '-', // Minor
                'maj7': '^7',
                'm7': '-7',
                '7': '7',
                'dim': 'o',
                'dim7': 'o7',
                '√∏7': 'h7',
                'aug': '+',
                'sus4': 'sus',
                '6': '6',
                'm6': '-6',
                '9': '9',
                '13': '13'
            };
            
            result += typeMap[chord.type] || chord.type;
            
            // Add inversion (bass note)
            if (chordItem.inversion) {
                result += '/' + chordItem.inversion;
            }
            
            return result;
        }
        
        // Generate iRealb format string
        function generateIRealbFormat() {
            const songName = document.getElementById('songName').value || 'Untitled';
            const author = document.getElementById('authorName').value || '';
            const musicStyle = document.getElementById('musicStyle').value || 'Medium Swing';
            const keySignature = document.getElementById('keySignature').value || 'C';
            const { numerator, denominator } = getTimeSignatureInfo();
            
            // Group chords by measure
            const chordsByMeasure = {};
            recordedChords.forEach(item => {
                if (!chordsByMeasure[item.measure]) {
                    chordsByMeasure[item.measure] = [];
                }
                chordsByMeasure[item.measure].push(item);
            });
            
            // Build chord string with sections and time signature
            let chordString = 'T' + numerator + denominator; // Time signature at start
            const measures = Object.keys(chordsByMeasure).map(m => parseInt(m)).sort((a, b) => a - b);
            let lastSection = null;
            
            // Determine the total measures to export
            const totalMeasuresInput = parseInt(document.getElementById('totalMeasures').value) || 32;
            const firstMeasure = measures.length > 0 ? measures[0] : 1;
            const lastMeasure = measures.length > 0 ? Math.max(...measures, totalMeasuresInput) : totalMeasuresInput;
            
            // Iterate through all measures from first to last
            for (let measureNum = firstMeasure; measureNum <= lastMeasure; measureNum++) {
                const chordsInMeasure = chordsByMeasure[measureNum];
                
                // Check for volta ending markers
                const voltaEnding = voltaEndings.find(v => v.measure === measureNum);
                if (voltaEnding) {
                    if (voltaEnding.type === 1) {
                        chordString += 'N'; // First ending
                    } else if (voltaEnding.type === 2) {
                        chordString += 'Q'; // Second ending
                    }
                }
                
                if (chordsInMeasure && chordsInMeasure.length > 0) {
                    // Sort chords by beat within the measure
                    chordsInMeasure.sort((a, b) => (a.beat || numerator) - (b.beat || numerator));
                    
                    // Check if this measure starts a new section
                    const firstChordSection = chordsInMeasure[0].section;
                    if (firstChordSection && firstChordSection !== lastSection) {
                        chordString += '*' + firstChordSection;
                        lastSection = firstChordSection;
                    }
                    
                    // Add chords with spacing based on beats
                    chordsInMeasure.forEach((item, chordIndex) => {
                        chordString += chordToIRealb(item);
                        
                        // Add space between chords in the same measure
                        if (chordIndex < chordsInMeasure.length - 1) {
                            chordString += ' ';
                        }
                    });
                } else {
                    // No chord in this measure - add repeat symbol
                    chordString += 'x';
                }
                
                // Add measure separator
                chordString += '|';
            }
            
            // Add final bar line
            chordString += 'Z';
            
            // iRealbook format: irealbook://SongName=Author=Style=Key=n=ChordData
            const irealbookUrl = `irealbook://${encodeURIComponent(songName)}=${encodeURIComponent(author)}=${encodeURIComponent(musicStyle)}=${encodeURIComponent(keySignature)}=n=${encodeURIComponent(chordString)}`;
            
            return irealbookUrl;
        }
        
        // Download as HTML file
        function downloadIRealbFile() {
            const songName = document.getElementById('songName').value || 'Untitled';
            const irealbUrl = generateIRealbFormat();
            
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${songName} - iRealPro Chart</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { color: #667eea; margin-bottom: 10px; }
        .meta { color: #666; margin-bottom: 30px; }
        .chords {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .chord-cell {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
        }
        .irealb-link {
            margin-top: 30px;
            padding: 15px;
            background: #e7f3ff;
            border-radius: 5px;
        }
        .irealb-link {
            margin-bottom: 30px;
            padding: 15px;
            background: #e7f3ff;
            border-radius: 5px;
            text-align: center;
        }
        .irealb-link a {
            display: inline-block;
            padding: 12px 24px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.1em;
            transition: background 0.3s;
        }
        .irealb-link a:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <h1>${songName}</h1>
        <div class="meta">
            <p><strong>Composer:</strong> ${document.getElementById('authorName').value || 'Unknown'}</p>
            <p><strong>Time Signature:</strong> ${getTimeSignatureInfo().numerator}/${getTimeSignatureInfo().denominator}</p>
        </div>
        <div class="irealb-link">
            <a href="${irealbUrl}" target="_blank">üéµ Export to iReal Pro</a>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                Click to open in iRealPro app (if installed)
            </p>
        </div>
        <div class="chords">
            ${(() => {
                // Group chords by measure for display
                const chordsByMeasure = {};
                recordedChords.forEach(item => {
                    if (!chordsByMeasure[item.measure]) {
                        chordsByMeasure[item.measure] = [];
                    }
                    chordsByMeasure[item.measure].push(item);
                });
                
                const measures = Object.keys(chordsByMeasure).sort((a, b) => parseInt(a) - parseInt(b));
                return measures.map(measureNum => {
                    const chordsInMeasure = chordsByMeasure[measureNum];
                    const chordTexts = chordsInMeasure.map(item => {
                        const chordText = item.chord.type ? `${item.chord.root}${item.chord.type}` : item.chord.root;
                        const inversionText = item.inversion ? `/${item.inversion}` : '';
                        return `${chordText}${inversionText}`;
                    }).join(' ');
                    return `<div class="chord-cell">${chordTexts}</div>`;
                }).join('');
            })()}
        </div>
    </div>
</body>
</html>`;
            
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${songName.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_')}_irealb.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Initialize MIDI
        async function initMIDI() {
            try {
                midiAccess = await navigator.requestMIDIAccess();
                updateMIDIStatus(t('irealbMaker.accessGranted'), true);
                populateInputDevices();
                midiAccess.onstatechange = populateInputDevices;
            } catch (error) {
                updateMIDIStatus(t('irealbMaker.accessDenied') + ' ' + error.message, false);
            }
        }
        
        function updateMIDIStatus(message, connected) {
            const statusEl = document.getElementById('midiStatus');
            const statusText = document.getElementById('statusText');
            statusText.textContent = message;
            statusEl.className = connected ? 'midi-status connected' : 'midi-status';
        }
        
        function populateInputDevices() {
            const select = document.getElementById('midiInput');
            select.innerHTML = `<option value="">${t('irealbMaker.noDeviceSelected')}</option>`;
            
            const inputs = Array.from(midiAccess.inputs.values());
            inputs.forEach((input, index) => {
                const option = document.createElement('option');
                option.value = input.id;
                option.textContent = input.name;
                if (index === 0) option.selected = true;
                select.appendChild(option);
            });
            
            if (inputs.length > 0) {
                selectInput(inputs[0].id);
            }
        }
        
        function selectInput(deviceId) {
            if (selectedInput) {
                selectedInput.onmidimessage = null;
            }
            
            if (deviceId && midiAccess) {
                selectedInput = midiAccess.inputs.get(deviceId);
                selectedInput.onmidimessage = handleMIDIMessage;
                updateMIDIStatus(t('irealbMaker.connectedTo') + ' ' + selectedInput.name, true);
            } else {
                selectedInput = null;
                updateMIDIStatus(t('irealbMaker.noDevice'), false);
            }
        }
        
        function handleMIDIMessage(event) {
            const [status, note, velocity] = event.data;
            const command = status & 0xF0;
            
            // Check if in edit mode first
            if (command === 0x90 && velocity > 0) {
                if (handleMIDIEdit(note, true)) return;
            } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
                if (handleMIDIEdit(note, false)) return;
            }
            
            if (command === 0x90 && velocity > 0) {
                // Note ON
                // If this is the first note pressed, capture the beat position
                if (activeNotes.size === 0 && isRecording && !isCountingIn) {
                    chordBeatPosition = currentBeat === 0 ? getTimeSignatureInfo().numerator : currentBeat;
                    chordMeasurePosition = window.actualStartMeasure + (currentMeasure - 2);
                    chordNotesPressed.clear(); // Start fresh for new chord
                }
                
                activeNotes.add(note);
                chordNotesPressed.add(note); // Track this note as part of the chord
                updateChordDisplay();
            } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
                // Note OFF
                activeNotes.delete(note);
                
                // When all notes are released, analyze and record the chord
                if (activeNotes.size === 0 && chordNotesPressed.size > 0) {
                    analyzeAndRecordChord();
                    chordNotesPressed.clear();
                    chordBeatPosition = null;
                    chordMeasurePosition = null;
                } else {
                    updateChordDisplay();
                }
            }
        }
        
        function analyzeAndRecordChord() {
            if (!isRecording || isCountingIn || chordNotesPressed.size === 0) {
                return;
            }
            
            // Analyze the complete set of notes that were pressed
            const noteNames = Array.from(chordNotesPressed)
                .sort((a, b) => a - b)
                .map(midiNoteToName);
            
            const chordInfo = detectChord(noteNames);
            if (!chordInfo) return;
            
            const chordText = chordInfo.type ? `${chordInfo.root}${chordInfo.type}` : chordInfo.root;
            const lastChordText = lastRecordedChord ? (lastRecordedChord.chord.type ? `${lastRecordedChord.chord.root}${lastRecordedChord.chord.type}` : lastRecordedChord.chord.root) : '';
            
            // Only record if chord has changed from the last recorded chord
            if (chordText !== lastChordText && chordBeatPosition !== null && chordMeasurePosition !== null) {
                // Automatically assign section based on defined sections
                const sectionInfo = getSectionForMeasure(chordMeasurePosition);
                
                const chordEntry = {
                    measure: chordMeasurePosition,
                    beat: chordBeatPosition,
                    chord: chordInfo,
                    inversion: '',
                    section: sectionInfo ? sectionInfo.type : '' // Auto-assign section if defined
                };
                recordedChords.push(chordEntry);
                lastRecordedChord = chordEntry;
                updateChordList();
                
                // Simple announcement: just chord name
                announceChange(chordText);
            }
        }
        
        function updateChordDisplay() {
            if (activeNotes.size === 0) {
                return;
            }
            
            const noteNames = Array.from(activeNotes)
                .sort((a, b) => a - b)
                .map(midiNoteToName);
            
            const chordInfo = detectChord(noteNames);
            currentChord = chordInfo;
            
            const chordNameEl = document.getElementById('chordName');
            if (chordInfo) {
                const chordFullName = chordInfo.type ? `${chordInfo.root} ${chordInfo.type}` : chordInfo.root;
                chordNameEl.textContent = chordFullName;
            }
        }
        
        // Event handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            const songName = document.getElementById('songName').value;
            if (!songName) {
                alert(t('irealbMaker.enterSongName'));
                return;
            }
            
            initAudio();
            
            // Handle overwrite mode: keep chords outside the recording range
            const startMeasure = parseInt(document.getElementById('startMeasure').value) || 1;
            const endMeasure = parseInt(document.getElementById('endMeasure').value);
            
            if (startMeasure > 1 || endMeasure) {
                // Overwrite mode: keep existing chords outside the range
                recordedChords = recordedChords.filter(chord => {
                    if (chord.measure < startMeasure) return true; // Keep chords before start
                    if (endMeasure && chord.measure > endMeasure) return true; // Keep chords after end
                    return false; // Remove chords in the recording range
                });
            } else {
                // Full re-record: clear everything
                recordedChords = [];
            }
            
            lastRecordedChord = null;
            chordNotesPressed.clear();
            chordBeatPosition = null;
            chordMeasurePosition = null;
            activeNotes.clear();
            window.lastAnnouncedSectionId = null; // Reset section announcement tracker
            updateChordList();
            updateStatusMessage('Count-in...', false);
            startMetronome();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('downloadBtn').disabled = true;
        });
        
        document.getElementById('stopBtn').addEventListener('click', () => {
            stopMetronome();
            isRecording = false;
            isCountingIn = false;
            updateStatusMessage('Recording stopped', false);
            announceCount('Recording stopped');
            window.lastAnnouncedSectionId = null; // Reset for next recording
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = recordedChords.length === 0;
        });
        
        document.getElementById('downloadBtn').addEventListener('click', () => {
            downloadIRealbFile();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            stopMetronome();
            isRecording = false;
            isCountingIn = false;
            recordedChords = [];
            definedSections = [];
            voltaEndings = [];
            currentChord = null;
            lastRecordedChord = null;
            chordNotesPressed.clear();
            chordBeatPosition = null;
            chordMeasurePosition = null;
            activeNotes.clear();
            updateChordList();
            updateStatusMessage('', false);
            document.getElementById('chordName').innerHTML = `<span class="placeholder-text">${t('irealbMaker.readyToRecord')}</span>`;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = true;
        });
        
        // Note: addSectionBtn removed - sections added via S key only
        // document.getElementById('addSectionBtn').addEventListener('click', addSection);
        
        document.getElementById('midiInput').addEventListener('change', (e) => {
            selectInput(e.target.value);
        });
        
        document.getElementById('backBtn').addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        
        // JSON Export: Save current progress
        document.getElementById('downloadJsonBtn').addEventListener('click', () => {
            const progressData = {
                version: '1.0',
                songInfo: {
                    name: document.getElementById('songName').value,
                    author: document.getElementById('authorName').value,
                    timeSignature: document.getElementById('timeSignature').value,
                    musicStyle: document.getElementById('musicStyle').value,
                    keySignature: document.getElementById('keySignature').value,
                    bpm: document.getElementById('bpm').value,
                    totalMeasures: document.getElementById('totalMeasures').value,
                    startMeasure: document.getElementById('startMeasure').value,
                    endMeasure: document.getElementById('endMeasure').value
                },
                recordedChords: recordedChords,
                definedSections: definedSections,
                voltaEndings: voltaEndings
            };
            
            const jsonStr = JSON.stringify(progressData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const songName = document.getElementById('songName').value || 'untitled';
            a.href = url;
            a.download = `${songName.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_')}_progress.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            announceChange('Progress saved to JSON file');
        });
        
        // JSON Import: Load saved progress
        document.getElementById('uploadJsonBtn').addEventListener('click', () => {
            document.getElementById('jsonFileInput').click();
        });
        
        document.getElementById('jsonFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const progressData = JSON.parse(event.target.result);
                    
                    // Validate version
                    if (!progressData.version || !progressData.songInfo) {
                        throw new Error('Invalid JSON format');
                    }
                    
                    // Restore song info
                    document.getElementById('songName').value = progressData.songInfo.name || '';
                    document.getElementById('authorName').value = progressData.songInfo.author || '';
                    document.getElementById('timeSignature').value = progressData.songInfo.timeSignature || '44';
                    document.getElementById('musicStyle').value = progressData.songInfo.musicStyle || 'Medium Swing';
                    document.getElementById('keySignature').value = progressData.songInfo.keySignature || 'C';
                    document.getElementById('bpm').value = progressData.songInfo.bpm || '120';
                    document.getElementById('totalMeasures').value = progressData.songInfo.totalMeasures || '32';
                    document.getElementById('startMeasure').value = progressData.songInfo.startMeasure || '1';
                    document.getElementById('endMeasure').value = progressData.songInfo.endMeasure || '';
                    
                    // Restore chords and sections
                    recordedChords = progressData.recordedChords || [];
                    definedSections = progressData.definedSections || [];
                    voltaEndings = progressData.voltaEndings || [];
                    
                    // Update displays (this will also update button states)
                    updateChordList();
                    updateSectionList();
                    
                    // Skip wizard and go straight to editing mode if chords were loaded
                    if (recordedChords.length > 0) {
                        startEditingMode();
                    }
                    
                    announceChange('Progress loaded from JSON file');
                } catch (error) {
                    alert('Error loading JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input so the same file can be loaded again
            e.target.value = '';
        });
        
        // LocalStorage functions for saving/loading songs
        const STORAGE_KEY = 'irealb_maker_songs';
        
        function getSavedSongs() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (error) {
                console.error('Error loading saved songs:', error);
                return [];
            }
        }
        
        function saveToLocalStorage() {
            const songName = document.getElementById('songName').value || 'Untitled';
            
            if (recordedChords.length === 0) {
                announceChange('No chords to save');
                return;
            }
            
            const songData = {
                name: songName,
                timestamp: Date.now(),
                songInfo: {
                    name: songName,
                    author: document.getElementById('authorName').value,
                    timeSignature: document.getElementById('timeSignature').value,
                    musicStyle: document.getElementById('musicStyle').value,
                    keySignature: document.getElementById('keySignature').value,
                    bpm: document.getElementById('bpm').value,
                    totalMeasures: document.getElementById('totalMeasures').value,
                    startMeasure: document.getElementById('startMeasure').value,
                    endMeasure: document.getElementById('endMeasure').value
                },
                recordedChords: recordedChords,
                definedSections: definedSections,
                voltaEndings: voltaEndings
            };
            
            try {
                const songs = getSavedSongs();
                // Check if song with same name exists
                const existingIndex = songs.findIndex(s => s.name === songName);
                if (existingIndex !== -1) {
                    songs[existingIndex] = songData;
                    announceChange(`Song "${songName}" updated in local storage`);
                } else {
                    songs.push(songData);
                    announceChange(`Song "${songName}" saved to local storage`);
                }
                localStorage.setItem(STORAGE_KEY, JSON.stringify(songs));
            } catch (error) {
                announceChange('Error saving to local storage: ' + error.message);
            }
        }
        
        function loadFromLocalStorage() {
            const songs = getSavedSongs();
            
            if (songs.length === 0) {
                announceChange('No saved songs found in local storage');
                return;
            }
            
            // Create a selection dialog
            let options = songs.map((song, index) => 
                `${index + 1}. ${song.name} (${new Date(song.timestamp).toLocaleDateString()})`
            ).join('\n');
            
            const selection = prompt(`Choose a song to load:\n\n${options}\n\nEnter number (1-${songs.length}):`);
            
            if (selection) {
                const index = parseInt(selection) - 1;
                if (index >= 0 && index < songs.length) {
                    const songData = songs[index];
                    
                    // Restore song info
                    document.getElementById('songName').value = songData.songInfo.name || '';
                    document.getElementById('authorName').value = songData.songInfo.author || '';
                    document.getElementById('timeSignature').value = songData.songInfo.timeSignature || '44';
                    document.getElementById('musicStyle').value = songData.songInfo.musicStyle || 'Medium Swing';
                    document.getElementById('keySignature').value = songData.songInfo.keySignature || 'C';
                    document.getElementById('bpm').value = songData.songInfo.bpm || '120';
                    document.getElementById('totalMeasures').value = songData.songInfo.totalMeasures || '32';
                    document.getElementById('startMeasure').value = songData.songInfo.startMeasure || '1';
                    document.getElementById('endMeasure').value = songData.songInfo.endMeasure || '';
                    
                    // Restore chords and sections
                    recordedChords = songData.recordedChords || [];
                    definedSections = songData.definedSections || [];
                    voltaEndings = songData.voltaEndings || [];
                    
                    // Update displays
                    updateChordList();
                    updateSectionList();
                    
                    announceChange(`Song "${songData.name}" loaded from local storage`);
                }
            }
        }
        
        function closeWithSavePrompt() {
            if (recordedChords.length > 0) {
                if (confirm('Save current song to local storage before closing?')) {
                    saveToLocalStorage();
                }
            }
            // Reset the form
            document.getElementById('resetBtn').click();
            announceChange('Workspace cleared');
        }
        
        // Section input mode
        let sectionInputMode = false;
        
        function addSectionViaKey(sectionType) {
            const sectionMap = {
                'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D',
                'q': 'Coda', 'i': 'Intro', 'o': 'Outro',
                'v': 'Verse', 'h': 'Chorus', 'r': 'Bridge'
            };
            
            const type = sectionMap[sectionType.toLowerCase()] || sectionType.toUpperCase();
            
            // Get the current measure from selection or use 1
            const cells = document.querySelectorAll('.chord-cell');
            const selectedCell = document.querySelector('.chord-cell.selected');
            const measure = selectedCell ? parseInt(selectedCell.getAttribute('data-measure')) : 1;
            
            definedSections.push({ type, measure });
            definedSections.sort((a, b) => a.measure - b.measure);
            updateSectionList();
            announceChange(`Section ${type} added at measure ${measure}`);
            sectionInputMode = false;
        }
        
        // Add volta (first/second ending) function
        function addVoltaEnding() {
            const cells = document.querySelectorAll('.chord-cell');
            const selectedCell = document.querySelector('.chord-cell.selected');
            const measure = selectedCell ? 
                parseInt(selectedCell.getAttribute('data-measure')) : 
                parseInt(document.getElementById('startMeasure').value) || 1;
            
            // Ask which type of ending (1 or 2)
            const endingType = prompt('Enter ending type (1 for first ending, 2 for second ending):', '1');
            
            if (endingType && (endingType === '1' || endingType === '2')) {
                // Check if volta already exists at this measure
                const existingIndex = voltaEndings.findIndex(v => v.measure === measure);
                if (existingIndex !== -1) {
                    voltaEndings[existingIndex].type = parseInt(endingType);
                    announceChange(`Volta ending updated to ${endingType} at measure ${measure}`);
                } else {
                    voltaEndings.push({ measure: measure, type: parseInt(endingType) });
                    voltaEndings.sort((a, b) => a.measure - b.measure);
                    announceChange(`Volta ending ${endingType} added at measure ${measure}`);
                }
                updateChordList();
                // Re-select the current chord
                const newCells = document.querySelectorAll('.chord-cell');
                const cellIndex = Array.from(newCells).findIndex(cell => 
                    parseInt(cell.getAttribute('data-measure')) === measure
                );
                if (cellIndex !== -1) {
                    selectChord(cellIndex);
                }
            } else if (endingType !== null) {
                announceChange('Invalid ending type. Use 1 or 2.');
            }
        }
        
        // Remove volta ending at current measure
        function removeVoltaEnding() {
            const cells = document.querySelectorAll('.chord-cell');
            const selectedCell = document.querySelector('.chord-cell.selected');
            
            if (!selectedCell) {
                announceChange('No measure selected');
                return;
            }
            
            const measure = parseInt(selectedCell.getAttribute('data-measure'));
            const index = voltaEndings.findIndex(v => v.measure === measure);
            
            if (index !== -1) {
                voltaEndings.splice(index, 1);
                updateChordList();
                announceChange(`Volta ending removed from measure ${measure}`);
                selectChord(Array.from(cells).indexOf(selectedCell));
            } else {
                announceChange(`No volta ending at measure ${measure}`);
            }
        }
        
        // Clipboard operations (cut, copy, paste)
        function getMarkerRange() {
            const startMeasure = parseInt(document.getElementById('startMeasure').value) || 1;
            const endMeasure = parseInt(document.getElementById('endMeasure').value) || parseInt(document.getElementById('totalMeasures').value) || 32;
            return { start: startMeasure, end: endMeasure };
        }
        
        function copyChords() {
            const range = getMarkerRange();
            clipboardChords = recordedChords.filter(chord => 
                chord.measure >= range.start && chord.measure <= range.end
            ).map(chord => ({...chord})); // Deep copy
            
            announceChange(`Copied ${clipboardChords.length} chord(s) from measures ${range.start} to ${range.end}`);
        }
        
        function cutChords() {
            const range = getMarkerRange();
            clipboardChords = recordedChords.filter(chord => 
                chord.measure >= range.start && chord.measure <= range.end
            ).map(chord => ({...chord})); // Deep copy
            
            // Remove chords in range
            recordedChords = recordedChords.filter(chord => 
                chord.measure < range.start || chord.measure > range.end
            );
            
            updateChordList();
            announceChange(`Cut ${clipboardChords.length} chord(s) from measures ${range.start} to ${range.end}`);
        }
        
        function pasteChords() {
            if (clipboardChords.length === 0) {
                announceChange('Clipboard is empty');
                return;
            }
            
            // Get the selected measure or use start marker
            const cells = document.querySelectorAll('.chord-cell');
            const selectedCell = document.querySelector('.chord-cell.selected');
            const targetMeasure = selectedCell ? 
                parseInt(selectedCell.getAttribute('data-measure')) : 
                parseInt(document.getElementById('startMeasure').value) || 1;
            
            // Calculate offset
            const firstMeasure = Math.min(...clipboardChords.map(c => c.measure));
            const offset = targetMeasure - firstMeasure;
            
            // Paste chords with offset
            const pastedChords = clipboardChords.map(chord => ({
                ...chord,
                measure: chord.measure + offset
            }));
            
            // Add to recorded chords
            recordedChords.push(...pastedChords);
            recordedChords.sort((a, b) => {
                if (a.measure !== b.measure) return a.measure - b.measure;
                return (a.beat || 1) - (b.beat || 1);
            });
            
            updateChordList();
            announceChange(`Pasted ${pastedChords.length} chord(s) at measure ${targetMeasure}`);
        }
        
        function deleteMarkerRange() {
            const range = getMarkerRange();
            const beforeCount = recordedChords.length;
            
            recordedChords = recordedChords.filter(chord => 
                chord.measure < range.start || chord.measure > range.end
            );
            
            const deleted = beforeCount - recordedChords.length;
            updateChordList();
            announceChange(`Deleted ${deleted} chord(s) from measures ${range.start} to ${range.end}`);
        }
        
        function deleteCurrentSection() {
            const cells = document.querySelectorAll('.chord-cell');
            const selectedCell = document.querySelector('.chord-cell.selected');
            
            if (!selectedCell) {
                announceChange('No chord selected');
                return;
            }
            
            const measure = parseInt(selectedCell.getAttribute('data-measure'));
            const sectionInfo = getSectionForMeasure(measure);
            
            if (!sectionInfo) {
                announceChange('No section found at current position');
                return;
            }
            
            // Get section range
            const sectionRange = getSectionRangeByIndex(sectionInfo.index);
            if (!sectionRange) {
                announceChange('Could not determine section range');
                return;
            }
            
            // Delete all chords in this section
            const beforeCount = recordedChords.length;
            recordedChords = recordedChords.filter(chord => 
                chord.measure < sectionRange.start || chord.measure > sectionRange.end
            );
            
            // Delete the section definition
            definedSections.splice(sectionInfo.index, 1);
            
            const deleted = beforeCount - recordedChords.length;
            updateChordList();
            updateSectionList();
            announceChange(`Deleted section ${sectionInfo.type} and ${deleted} chord(s) from measures ${sectionRange.start} to ${sectionRange.end}`);
        }
        
        function focusWorkspace() {
            const workspace = document.getElementById('chordSequenceSection');
            if (workspace) {
                workspace.focus();
                // Select first chord if nothing is selected
                const cells = document.querySelectorAll('.chord-cell');
                if (cells.length > 0 && selectedChordIndex === -1) {
                    selectChord(0);
                } else if (selectedChordIndex >= 0) {
                    // Re-announce current selection
                    selectChord(selectedChordIndex);
                } else {
                    announceChange(t('irealbMaker.recordedChords'));
                }
            }
        }
        
        // Add keyboard navigation to workspace
        function handleWorkspaceKeydown(e) {
            const cells = document.querySelectorAll('.chord-cell');
            if (cells.length === 0) return;
            
            // Initialize selection if needed
            if (selectedChordIndex === -1 && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                e.preventDefault();
                selectChord(0);
                return;
            }
            
            // Delegate to chord cell handler if a chord is selected
            if (selectedChordIndex >= 0 && selectedChordIndex < cells.length) {
                const selectedCell = cells[selectedChordIndex];
                if (selectedCell) {
                    // Pass the selected cell as a parameter
                    handleChordCellKeydown(e, selectedCell);
                }
            }
        }
        
        // Update translations
        function updateTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                element.textContent = t(key);
            });
            document.documentElement.lang = getCurrentLanguage();
        }
        
        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input field (except for workspace)
            if ((e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') && 
                !e.target.classList.contains('workspace')) {
                return;
            }
            
            // Handle section input mode
            if (sectionInputMode) {
                const key = e.key.toLowerCase();
                if (['a', 'b', 'c', 'd', 'q', 'i', 'o', 'v', 'h', 'r'].includes(key)) {
                    e.preventDefault();
                    addSectionViaKey(key);
                } else if (e.key === 'Escape') {
                    sectionInputMode = false;
                    announceChange('Section input cancelled');
                }
                return;
            }
            
            // Ctrl+Shift combinations (must check before Shift or Ctrl alone)
            if (e.ctrlKey && e.shiftKey) {
                // No Ctrl+Shift combinations currently used
                // (Removed Ctrl+Shift+E as it's now just N)
                return;
            }
            
            // Ctrl key combinations (without Shift)
            if (e.ctrlKey && !e.shiftKey) {
                switch(e.key.toLowerCase()) {
                    case ',':
                        // Ctrl+,: Open settings wizard
                        e.preventDefault();
                        openSetupWizard();
                        break;
                    
                    case 'x':
                        // Ctrl+X: Cut
                        e.preventDefault();
                        cutChords();
                        break;
                        
                    case 'c':
                        // Ctrl+C: Copy
                        e.preventDefault();
                        copyChords();
                        break;
                        
                    case 'v':
                        // Ctrl+V: Paste
                        e.preventDefault();
                        pasteChords();
                        break;
                }
                return;
            }
            
            // Shift key combinations (without Ctrl)
            if (e.shiftKey && !e.ctrlKey) {
                switch(e.key.toUpperCase()) {
                    case 'E':
                        // Shift+E: Edit chord via keyboard
                        e.preventDefault();
                        const cells = document.querySelectorAll('.chord-cell');
                        const selectedCell = document.querySelector('.chord-cell.selected');
                        if (selectedCell) {
                            const dataIndex = selectedCell.getAttribute('data-index');
                            if (dataIndex !== null) {
                                editChord(parseInt(dataIndex), true);
                            }
                        } else {
                            announceChange('No chord selected. Use arrow keys to select a chord first.');
                        }
                        break;
                    
                    case 'BACKSPACE':
                        // Shift+Backspace: Delete current section
                        e.preventDefault();
                        deleteCurrentSection();
                        break;
                        
                    case 'S':
                        // Shift+S: Save to localStorage
                        e.preventDefault();
                        saveToLocalStorage();
                        break;
                        
                    case 'O':
                        // Shift+O: Open from localStorage
                        e.preventDefault();
                        loadFromLocalStorage();
                        break;
                        
                    case 'D':
                        // Shift+D: Download iReal file
                        e.preventDefault();
                        if (!document.getElementById('downloadBtn').disabled) {
                            document.getElementById('downloadBtn').click();
                            announceChange('Downloading iReal Pro file');
                        } else {
                            announceChange('No chords to download');
                        }
                        break;
                        
                    case 'J':
                        // Shift+J: Download JSON or load JSON
                        e.preventDefault();
                        if (recordedChords.length > 0) {
                            // Download JSON
                            document.getElementById('downloadJsonBtn').click();
                            announceChange('Downloading progress as JSON');
                        } else {
                            // Load JSON
                            document.getElementById('uploadJsonBtn').click();
                            announceChange('Choose JSON file to load');
                        }
                        break;
                        
                    case 'W':
                        // Shift+W: Close with save prompt
                        e.preventDefault();
                        closeWithSavePrompt();
                        break;
                }
                return;
            }
            
            // Regular key shortcuts (no shift, no ctrl)
            if (!e.shiftKey && !e.ctrlKey) {
                switch(e.key.toLowerCase()) {
                    case 'h':
                        // H key - Toggle help visibility
                        e.preventDefault();
                        const helpSection = document.getElementById('keyboardShortcuts');
                        if (helpSection) {
                            if (helpSection.style.display === 'none') {
                                helpSection.style.display = 'block';
                                announceChange('Keyboard shortcuts help shown');
                            } else {
                                helpSection.style.display = 'none';
                                announceChange('Keyboard shortcuts help hidden');
                            }
                        }
                        break;
                    
                    case 'r':
                        // R key - Record/Stop
                        e.preventDefault();
                        if (isRecording || isCountingIn) {
                            document.getElementById('stopBtn').click();
                            announceChange('Recording stopped');
                        } else {
                            document.getElementById('startBtn').click();
                            announceChange('Recording started');
                        }
                        break;
                        
                    case 's':
                        // S key - Add section (next key determines type)
                        e.preventDefault();
                        sectionInputMode = true;
                        announceChange('Section input mode: Press A for section A, B, C, D, Q for Coda, I for Intro, etc.');
                        break;
                    
                    case 'v':
                        // V key - Add volta (first/second ending)
                        e.preventDefault();
                        addVoltaEnding();
                        break;
                        
                    case 'n':
                        // N key - Focus workspace (MuseScore style)
                        e.preventDefault();
                        focusWorkspace();
                        break;
                    
                    case 't':
                        // T key - Open tempo/BPM settings
                        e.preventDefault();
                        openTempoModal();
                        break;
                    
                    case 'm':
                        // M key - Open MIDI device selection
                        e.preventDefault();
                        openMidiDeviceModal();
                        break;
                    
                    case ' ':
                        // Spacebar - Play/pause chord playback
                        e.preventDefault();
                        togglePlayback();
                        break;
                        
                    case 'e':
                        // E key - Edit chord via MIDI
                        e.preventDefault();
                        const cells = document.querySelectorAll('.chord-cell');
                        const selectedCell = document.querySelector('.chord-cell.selected');
                        if (selectedCell) {
                            const dataIndex = selectedCell.getAttribute('data-index');
                            if (dataIndex !== null) {
                                editChord(parseInt(dataIndex), false);
                            }
                        } else {
                            announceChange('No chord selected. Use arrow keys to select a chord first.');
                        }
                        break;
                    
                    case 'delete':
                        // Delete key - Delete entire marker range
                        e.preventDefault();
                        deleteMarkerRange();
                        break;
                        
                    case 'escape':
                        // Escape - Cancel various modes
                        e.preventDefault();
                        if (editingChordIndex !== -1) {
                            editingChordIndex = -1;
                            editingChordNotes.clear();
                            allEditNotes.clear();
                            announceChange('Edit mode cancelled');
                            
                            // Remove visual feedback
                            const cells = document.querySelectorAll('.chord-cell');
                            cells.forEach(cell => {
                                cell.style.background = '';
                                cell.style.animation = '';
                            });
                        } else if (sectionInputMode) {
                            sectionInputMode = false;
                            announceChange('Section input cancelled');
                        }
                        break;
                }
            }
        });
        
        // Modal and UI Management Functions
        let isEditingMode = false;
        let isPlayingBack = false;
        let playbackInterval = null;
        
        function openSetupWizard() {
            const modal = document.getElementById('setupWizardModal');
            modal.classList.add('active');
            
            // Focus the first input
            const firstInput = document.getElementById('wizard-songName');
            if (firstInput) {
                setTimeout(() => firstInput.focus(), 100);
            }
            
            announceChange('Song setup wizard opened. Press Escape to close.');
        }
        
        function closeSetupWizard() {
            const modal = document.getElementById('setupWizardModal');
            modal.classList.remove('active');
        }
        
        function startEditingMode() {
            isEditingMode = true;
            document.body.classList.add('editing-mode');
            closeSetupWizard();
            
            // Hide setup sections - specifically target non-workspace sections
            const sectionsToHide = document.querySelectorAll('.irealb-maker-section > .chord-sequence');
            sectionsToHide.forEach(el => {
                if (el.id !== 'chordSequenceSection' && !el.classList.contains('workspace')) {
                    el.style.display = 'none';
                }
            });
            
            // Hide device group
            document.querySelectorAll('.device-group').forEach(el => {
                el.style.display = 'none';
            });
            
            // Show workspace
            const workspace = document.getElementById('chordSequenceSection');
            if (workspace) {
                workspace.style.display = 'block';
                updateChordList();
                focusWorkspace();
            }
            
            announceChange('Editing mode started. Press N to focus workspace, T for tempo, M for MIDI devices, Ctrl+comma for settings.');
        }
        
        function openTempoModal() {
            const modal = document.getElementById('tempoModal');
            const modalBpm = document.getElementById('modalBpm');
            const currentBpm = document.getElementById('bpm');
            
            if (currentBpm) {
                modalBpm.value = currentBpm.value;
            }
            
            modal.classList.add('active');
            modalBpm.focus();
            announceChange('Tempo settings opened');
        }
        
        function closeTempoModal() {
            const modal = document.getElementById('tempoModal');
            const modalBpm = document.getElementById('modalBpm');
            const currentBpm = document.getElementById('bpm');
            
            if (currentBpm) {
                currentBpm.value = modalBpm.value;
            }
            
            modal.classList.remove('active');
            announceChange(`Tempo set to ${modalBpm.value} BPM`);
        }
        
        function openMidiDeviceModal() {
            const modal = document.getElementById('midiDeviceModal');
            const modalSelect = document.getElementById('modalMidiInput');
            const currentSelect = document.getElementById('midiInput');
            
            // Copy options from main select to modal select
            modalSelect.innerHTML = currentSelect.innerHTML;
            modalSelect.value = currentSelect.value;
            
            modal.classList.add('active');
            modalSelect.focus();
            announceChange('MIDI device selection opened');
        }
        
        function closeMidiDeviceModal() {
            const modal = document.getElementById('midiDeviceModal');
            const modalSelect = document.getElementById('modalMidiInput');
            const currentSelect = document.getElementById('midiInput');
            
            currentSelect.value = modalSelect.value;
            // Trigger change event to update MIDI input
            const event = new Event('change');
            currentSelect.dispatchEvent(event);
            
            modal.classList.remove('active');
            announceChange('MIDI device selection closed');
        }
        
        function togglePlayback() {
            if (recordedChords.length === 0) {
                announceChange('No chords to play back');
                return;
            }
            
            if (isPlayingBack) {
                // Stop playback
                isPlayingBack = false;
                if (playbackInterval) {
                    clearInterval(playbackInterval);
                    playbackInterval = null;
                }
                announceChange('Playback stopped');
            } else {
                // Start playback
                isPlayingBack = true;
                announceChange('Playback started');
                
                let currentIndex = selectedChordIndex >= 0 ? selectedChordIndex : 0;
                const cells = document.querySelectorAll('.chord-cell');
                const bpm = parseInt(document.getElementById('bpm')?.value || 120);
                const beatDuration = 60000 / bpm; // milliseconds per beat
                
                playbackInterval = setInterval(() => {
                    if (currentIndex >= cells.length) {
                        // Reached end, stop playback
                        isPlayingBack = false;
                        if (playbackInterval) {
                            clearInterval(playbackInterval);
                            playbackInterval = null;
                        }
                        announceChange('Playback completed');
                        return;
                    }
                    
                    selectChord(currentIndex);
                    currentIndex++;
                }, beatDuration);
            }
        }
        
        // Expose functions to global scope for inline onclick handlers
        window.setRecordMarker = setRecordMarker;
        window.editChord = editChord;
        window.addInversion = addInversion;
        window.setInversion = setInversion;
        window.closeInversionDialog = closeInversionDialog;
        window.deleteChord = deleteChord;
        window.addSection = addSection;
        window.deleteSection = deleteSection;
        window.copyFromPreviousSection = copyFromPreviousSection;
        window.markSection = markSection;
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            updateTranslations();
            initMIDI();
            
            // Add keyboard handler to workspace
            const workspace = document.getElementById('chordSequenceSection');
            if (workspace) {
                workspace.addEventListener('keydown', handleWorkspaceKeydown);
            }
            
            // Setup modal event listeners
            document.getElementById('wizardDoneBtn')?.addEventListener('click', () => {
                const wizardSongName = document.getElementById('wizard-songName');
                const songName = wizardSongName ? wizardSongName.value : document.getElementById('songName').value;
                
                if (!songName.trim()) {
                    announceChange(t('irealbMaker.enterSongName'));
                    return;
                }
                
                // Sync wizard values back to main form
                if (wizardSongName) {
                    document.getElementById('songName').value = wizardSongName.value;
                    document.getElementById('authorName').value = document.getElementById('wizard-authorName')?.value || '';
                    document.getElementById('timeSignature').value = document.getElementById('wizard-timeSignature')?.value || '44';
                    document.getElementById('musicStyle').value = document.getElementById('wizard-musicStyle')?.value || 'Medium Swing';
                    document.getElementById('keySignature').value = document.getElementById('wizard-keySignature')?.value || 'C';
                    document.getElementById('bpm').value = document.getElementById('wizard-bpm')?.value || '120';
                    document.getElementById('totalMeasures').value = document.getElementById('wizard-totalMeasures')?.value || '32';
                    // Note: startMeasure and endMeasure are set via [ and ] keyboard markers during editing, not in wizard
                }
                
                startEditingMode();
            });
            
            document.getElementById('wizardCancelBtn')?.addEventListener('click', closeSetupWizard);
            
            document.getElementById('tempoCloseBtn')?.addEventListener('click', closeTempoModal);
            
            document.getElementById('midiDeviceCloseBtn')?.addEventListener('click', closeMidiDeviceModal);
            
            // Close modals on Escape key
            document.querySelectorAll('.modal-overlay').forEach(modal => {
                modal.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        // Call appropriate close function based on modal
                        if (modal.id === 'setupWizardModal') {
                            closeSetupWizard();
                        } else if (modal.id === 'tempoModal') {
                            closeTempoModal();
                        } else if (modal.id === 'midiDeviceModal') {
                            closeMidiDeviceModal();
                        }
                    }
                });
                
                // Close modal when clicking overlay (outside dialog)
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        // Call appropriate close function based on modal
                        if (modal.id === 'setupWizardModal') {
                            closeSetupWizard();
                        } else if (modal.id === 'tempoModal') {
                            closeTempoModal();
                        } else if (modal.id === 'midiDeviceModal') {
                            closeMidiDeviceModal();
                        }
                    }
                });
            });
            
            // Show setup wizard on initial load if no song loaded
            const isNewSong = recordedChords.length === 0;
            if (isNewSong) {
                openSetupWizard();
            }
        });
    </script>
</body>
</html>
