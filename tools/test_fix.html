<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>iReal Pro Export Test</title>
</head>
<body>
    <h1>iReal Pro Export Test</h1>
    <p>This page tests the iReal Pro export functionality.</p>
    <div id="output"></div>

    <script type="module">
        // Mock the necessary functions and variables that are normally in irealb-maker.html
        let recordedChords = [];
        let definedSections = [];
        let voltaEndings = [];
        let repeatRegions = [];

        // Mock the DOM elements that the functions rely on
        document.body.innerHTML += `
            <input type="hidden" id="songName" value="">
            <input type="hidden" id="authorName" value="">
            <input type="hidden" id="timeSignature" value="44">
            <input type="hidden" id="musicStyle" value="Medium Swing">
            <input type="hidden" id="keySignature" value="C">
            <input type="hidden" id="totalMeasures" value="32">
        `;

        function getTimeSignatureInfo() {
            const ts = document.getElementById('timeSignature').value;
            const numerator = parseInt(ts[0]);
            const denominator = parseInt(ts[1]);
            return { numerator, denominator };
        }

        // Copy the updated functions from irealb-maker.html
        function chordToIRealb(chordItem) {
            if (!chordItem || !chordItem.chord) return ' ';

            const chord = chordItem.chord;
            let result = chord.root;
            let type = chord.type;

            const typeMap = {
                '': '', // Major triad
                'm': '-',
                'maj7': '^7',
                'maj9': '^9',
                'maj7(9)': '^9', // From chord detector
                'm7': '-7',
                'm9': '-9',
                'm7(9)': '-9', // From chord detector
                'm11': '-11',
                'm7(11)': '-11',
                'm13': '-13',
                'm7(13)': '-13',
                '7': '7',
                '9': '9',
                '11': '11',
                '13': '13',
                'dim': 'o',
                'dim7': 'o7',
                'h7': 'h7', // half-diminished
                'Ã¸7': 'h7', // half-diminished symbol
                'm7b5': 'h7', // half-diminished
                'aug': '+',
                '+': '+',
                'sus4': 'sus',
                'sus': 'sus',
                '7sus4': '7sus',
                '6': '6',
                'm6': '-6',
                '6/9': '69',
                'm6/9': '-69',
                '7(b9)': '7b9',
                '7(#9)': '7#9',
                '7(b5)': '7b5',
                '7(#5)': '7#5',
                '7(b13)': '7b13',
                '13(b9)': '13b9',
                '7(#9,b13)': '7alt',
                '7(#9,b5)': '7alt',
                '7(b9,b5)': '7alt',
                '7(b9,#5)': '7alt',
                '7alt': '7alt'
            };

            if (type in typeMap) {
                result += typeMap[type];
            } else {
                // Fallback for any unhandled complex types: remove parentheses and commas
                result += type.replace(/[(),]/g, '');
            }

            // Add inversion (bass note)
            if (chordItem.inversion) {
                result += '/' + chordItem.inversion;
            }

            return result;
        }

        function generateIRealbFormat() {
            const songName = document.getElementById('songName').value || 'Untitled';
            const author = document.getElementById('authorName').value || '';
            const musicStyle = document.getElementById('musicStyle').value || 'Medium Swing';
            const keySignature = document.getElementById('keySignature').value || 'C';
            const { numerator, denominator } = getTimeSignatureInfo();
            const totalMeasures = parseInt(document.getElementById('totalMeasures').value) || 32;

            const filteredChords = recordedChords.filter(c => c.measure <= totalMeasures);

            const chordsByMeasure = {};
            filteredChords.forEach(item => {
                if (!chordsByMeasure[item.measure]) {
                    chordsByMeasure[item.measure] = [];
                }
                chordsByMeasure[item.measure].push(item);
            });

            let chordString = 'T' + numerator + denominator;
            let lastSection = null;

            function getRepeatContext(measureNum) {
                for (const region of repeatRegions) {
                    if (measureNum === region.repriseStart) return { type: 'repriseStart', region };
                    if (measureNum === region.volta1End) return { type: 'volta1End', region };
                    if (measureNum === region.volta1Start) return { type: 'volta1Start', region };
                    if (measureNum === region.volta2Start) return { type: 'volta2Start', region };
                }
                return null;
            }

            function isHiddenRepriseMeasure(measureNum) {
                for (const region of repeatRegions) {
                    const repriseLength = region.repriseEnd - region.repriseStart + 1;
                    const hiddenStart = region.volta2Start - repriseLength;
                    const hiddenEnd = region.volta2Start - 1;
                    if (measureNum >= hiddenStart && measureNum <= hiddenEnd) {
                        return true;
                    }
                }
                return false;
            }

            for (let measureNum = 1; measureNum <= totalMeasures; measureNum++) {
                 if (isHiddenRepriseMeasure(measureNum)) {
                    continue;
                }
                const chordsInMeasure = chordsByMeasure[measureNum];
                const repeatContext = getRepeatContext(measureNum);

                if (repeatContext && repeatContext.type === 'repriseStart') {
                    chordString += '{';
                }

                const voltaEnding = voltaEndings.find(v => v.measure === measureNum);
                if (voltaEnding) {
                    const isVoltaStart = !voltaEndings.find(v => v.measure === measureNum - 1 && v.type === voltaEnding.type);
                    if (isVoltaStart) {
                        chordString += `N${voltaEnding.type}`;
                    }
                }

                const sectionAtMeasure = definedSections.find(s => s.measure === measureNum);
                if (sectionAtMeasure) {
                    if (sectionAtMeasure.type !== lastSection) {
                        chordString += `*${sectionAtMeasure.type}`;
                        lastSection = sectionAtMeasure.type;
                    }
                }

                if (chordsInMeasure && chordsInMeasure.length > 0) {
                    chordsInMeasure.sort((a, b) => (a.beat || 1) - (b.beat || 1));
                    chordsInMeasure.forEach((item, index) => {
                        chordString += chordToIRealb(item);
                        if (index < chordsInMeasure.length - 1) {
                            chordString += ' ';
                        }
                    });
                } else {
                    chordString += 'x';
                }

                if (repeatContext && repeatContext.type === 'volta1End') {
                    chordString += ' } ';
                }

                chordString += '|';
            }

            chordString += 'Z';

            const irealbookUrl = `irealbook://${encodeURIComponent(songName)}=${encodeURIComponent(author)}=${encodeURIComponent(musicStyle)}=${encodeURIComponent(keySignature)}=n=${encodeURIComponent(chordString)}`;

            return irealbookUrl;
        }

        // Fetch the test data and run the test
        fetch('../error/Ded Moroz is coming to town_progress.json')
            .then(response => response.json())
            .then(data => {
                // Populate the global variables with the test data
                recordedChords = data.recordedChords;
                definedSections = data.definedSections;
                voltaEndings = data.voltaEndings;
                repeatRegions = data.repeatRegions;

                // Populate the mock DOM elements
                document.getElementById('songName').value = data.songInfo.name;
                document.getElementById('authorName').value = data.songInfo.author;
                document.getElementById('timeSignature').value = data.songInfo.timeSignature;
                document.getElementById('musicStyle').value = data.songInfo.musicStyle;
                document.getElementById('keySignature').value = data.songInfo.keySignature;
                document.getElementById('totalMeasures').value = data.songInfo.totalMeasures;

                // Run the function and display the output
                const url = generateIRealbFormat();
                document.getElementById('output').innerText = url;
            })
            .catch(error => {
                document.getElementById('output').innerText = 'Error loading test data: ' + error;
            });
    </script>
</body>
</html>
